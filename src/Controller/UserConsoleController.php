<?php
// src/Controller/UserConsoleController.php
namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Helper\Table;
use Symfony\Component\Console\Helper\TableCell;
use Symfony\Component\Console\Helper\TableSeparator;

/**
 * This class is a handler for interacting with the user via the command line.
 * With this class you can: draw a fancy header, clear the screen, or ask the user a question.
 * 
 * Questions can either be an options list or a basic string.
 * If the question is an options list, a table is rendered to the command line via Symfony's table helper.
 * To use this class:
 * 1.) Create the object, but be sure to pass a header string as well as Symfony's OutputInterface Object
 * 2.) Set the question by setting $this->question
 *     (Optional) set the options list by setting $this->options_list
 *     (Optional) set the total_questions (if you want to print out question progress)
 *     (Optional) set $this->help_text to give the user some context of the asked question
 * 3.) Call askQuestion() to ask the question which will return the user response
 * 
 * Subsequent questions can be initiated through use of the reset() function.
 */
class UserConsoleController
{
    CONST MAX_ROWS = 20;
    CONST MAX_COLUMNS = 10;
    CONST CLEAR_SCREEN = "\033\143";
    CONST MOVE_TERMINAL_CURSOR_UP_TWO_LINES = "\e[2A";
    CONST LIST_PROMPT = "\nInput a #, use n or p to switch pages";
    CONST LINE_BREAK = "\n";

    public $question;                //@string  The question to ask the user
    public $options_list;            //@array   The options list content ['column' => ['row1', 'row2'], 'column2' => [...], ...]
    public $current_page;            //@int     The current page of the user generated question list
    public $selected_answer;         //@mixed   The user's answer
    public $output;                  //@object  Symfony's OutputInterface Object
    public $rows;                    //@array   The rows generated by generateTableRows()
    public $pages;                   //@array   The paginated rows of data, basically $this->rows chopped up to adhere to SELF::MAX_ROWS
    public $table;                   //@object  Symfony's Table object which is used to render data to the cli
    public $headers;                 //@array   The headers for each column of the table, aka the array keys of $this->options_list
    public $cli_header;              //@string  The passed command line header, it is used when the screen is redrawn before a table render occurs
    public $help_text;               //@string  Settable help text that should be used to give the user context of the question being asked
    public $question_count = 0;      //@int     A counter to keep track of how many questions have been asked with this class
    public $total_questions = FALSE; //@mixed   If set to an int, a prompt message displaying question progress will be rendered.

    /**
     * Initializes the object, and draws the header to the cli.
     * 
     * @param string $header - The text to display when construct fires off.
     * @param object $output - An instance of Symfony's OutputInterface object
     */
    public function __construct(string $header = '', object $output = NULL)
    {
        $this->question = FALSE;
        $this->options_list = FALSE;
        $this->table = FALSE;
        $this->help_text = FALSE;
        $this->cli_header = $header;
        $this->output = $output;
        $this->question_count++;
        $this->drawCliHeader();
    }

    /**
     * Determines if there is a question to be asked, and asks the questions.
     * If $this->options_list is not false, we ask the question through use of
     * Symfony's tables.
     * 
     * @return mixed $this->selected_answer - The user's answer to the question.
     */
    public function askQuestion()
    {
        if ($this->question !== FALSE) {
            if ($this->options_list !== FALSE) {
                $this->prepTableData();
                $answer = FALSE;
                $this->current_page = 1;
    
                while ($answer !== TRUE) {
                    $this->drawCliHeader();
                    $this->drawProgress();
                    $this->output->writeln([SELF::LINE_BREAK . $this->question]);
                    $this->helpText();
                    $this->renderTable();
                    $user_response = $this->userInput();
                    $answer = $this->processListAnswer($user_response);
                }
            } else {
                $this->drawCliHeader();
                $this->drawProgress();
                $this->output->writeln([SELF::LINE_BREAK . $this->question]);
                $this->helpText();
                $this->selected_answer = $this->userInput();
            }
            return $this->selected_answer;
        }
    }

    /**
     * This function prompts the user for their answer. Once answered, 
     * we move the terminal up two lines and return the response
     * 
     * @return string $user_response - The user's answer to the question
     */
    private function userInput()
    {
        $user_response = readline("$: ");
        $this->resetCursor();
        return $user_response;
    }

    /**
     * This funciton checks to see if $this->total_questions is not false.
     * If not false, a Prompt progress message is drawn in the cli so that the user knows how many more questions are left to answer.
     */
    private function drawProgress()
    {
        if ($this->total_questions !== FALSE) {
            $this->output->writeln([SELF::LINE_BREAK . "[Prompt " . $this->question_count . "/" . $this->total_questions . "]"]);
        }
    }

    /**
     * This function resets variables in this class so that we can ask additional questions without needing to create a new object
     */
    public function reset()
    {
        $this->__construct($this->cli_header, $this->output);
    }

    /**
     * This function draws help text to the cli if the help text has been set
     */
    private function helpText()
    {
        if ($this->help_text !== FALSE) {
            $this->output->writeln([SELF::LINE_BREAK . $this->help_text . SELF::LINE_BREAK]);
        }
    }

    /**
     * This function generates the Symfony table and subsequent list prompt.
     */
    private function renderTable()
    {
        $this->generateQuestionTable($this->pages[$this->current_page]);
        $this->table->setFooterTitle('[Page ' . $this->current_page . '/' . count($this->pages) . ']');
        $this->table->setStyle('box');
        $this->table->render();
        $this->output->writeln(SELF::LIST_PROMPT);
    }

    /**
     * This function handles the answer given by the user if the question was a list of options.
     * 
     * @param string $answer - The user's response from the readLine prompt.
     */
    private function processListAnswer($answer)
    {
        if (strtolower($answer) == 'n' && isset($this->pages[$this->current_page + 1])) {
            $this->current_page++;
        } else if (strtolower($answer) == 'p' && isset($this->pages[$this->current_page - 1])) {
            $this->current_page--;
        } else if (is_numeric($answer)) {
            foreach ($this->rows as $row => $row_content) {
                if ($answer == trim($row_content[0], '[]')) {
                    $answer_values = [];
                    foreach ($this->headers as $header_key => $header) {
                        if ($header_key !== 0) {
                            $answer_values[trim($header)] = $row_content[$header_key];
                        }
                    }
                    $this->selected_answer = $answer_values;
                    return TRUE;
                }
            }
        }
        return FALSE;
    }

    /**
     * This function clears the screen and then draws a fancy looking header with Symfony's tables
     */
    public function drawCliHeader()
    {
        $this->clearScreen();
        $command_header_table = new Table($this->output);
        $command_header_table->setHeaders([$this->cli_header])->setRows([]);
        $command_header_table->setStyle('box-double');
        $command_header_table->render();
    }

    /**
     * Clear the screen using the predefined string constant.
     */
    public function clearScreen()
    {
        echo SELF::CLEAR_SCREEN;
    }

    /**
     * Moves the cursor up two lines on the screen via the predefined string constant.
     */
    public function resetCursor()
    {
        echo SELF::MOVE_TERMINAL_CURSOR_UP_TWO_LINES;
    }

    /**
     * Generate a Symfony Table using the passed data, and set it to the class variable for later use.
     * 
     * @param array $data_array - a multidimensional arrays of pre defined headers and rows
     */
    private function generateQuestionTable($data_array)
    {
        //Generate the table
        $this->table = new Table($this->output);
        $headers = $data_array['headers'];
        $rows = $data_array['rows'];
        $this->table->setHeaders($headers)->setRows($rows);
    }

    /**
     * Run the functions responsible for arranging the data into the proper format.
     * This makes the passed data in $this->options_list useable with Symfony's tables.
     */
    private function prepTableData()
    {
        //Remove columns that exceed the maximum column limit
        $raw_list = $this->enforceColumnLimit($this->options_list);

        //Generate the selection column
        $raw_list = $this->generateSelectionColumn($raw_list);

        //Extract the header names
        $headers = $this->extractHeaders($raw_list);

        //Generate the rows
        $rows = $this->generateTableRows($raw_list);
        $this->rows = $rows;

        //Paginate the data to enforce the max rows
        $pages = $this->paginateTableRows($rows, $headers);
        $this->pages = $pages;
    }

    /**
     * This function takes the raw_list (aka $this->options_list) and extracts the headers.
     * If the header is too short it's inflated with empty spaces (this was an easy fix for the footer sometimes getting truncated)
     * 
     * @param array $raw_list - A version of $this->options_list after it's been partially processed by $this->prepTableData()
     * @return array $headers - The column headers for use in Symfony's tables
     */
    private function extractHeaders($raw_list)
    {
        $headers = array_keys($raw_list);
        $this->headers = $headers;
        foreach ($headers as $key => $header) {
            if (strlen($header) < 7) {
                //Inflate the header for readability if it's too short
                $headers[$key] = '   ' . $header . '   ';
            }
        }
        return $headers;
    }

    /**
     * This function breaks the table rows up into pages so that the MAX_ROWS constant is adhered to
     * 
     * @param array $rows - the complete list of rows that we want to break up into pages
     * @param array $headers - the headers for each column of the table we're building
     * @return array $tables - the array of pages that will eventually be turned into viewable tables for the user
     */
    private function paginateTableRows($rows, $headers)
    {
        $count = 1;
        $current_rows = [];
        $tables = [];
        $page = 1;

        //Actually paginate the data
        foreach ($rows as $row_number => $row_data) {
            if ($count > SELF::MAX_ROWS) {
                $tables[$page]['rows'] = $current_rows;
                $tables[$page]['headers'] = $headers;
                $current_rows = [];
                $count = 1;
                $page++;
            }
            $current_rows[] = $row_data;
            $count++;
        }
        $tables[$page]['rows'] = $current_rows;
        $tables[$page]['headers'] = $headers;
        return $tables;
    }

    /**
     * This function appends a column to the beginning of the $raw_list array (aka $this->options_list)
     * This new column is used to help the user select a specific row when the Symfony table is drawn.
     * 
     * @param array $raw_list - A version of $this->options_list after it's been partially processed by $this->prepTableData()
     * @param array $new_list - Basically a copy of $raw_list, but with a new column added before the rest.
     */
    private function generateSelectionColumn($raw_list)
    {
        //Counts start at 1 so that the selection column starts at 1 and not 0
        $row_count = 1;
        foreach ($raw_list as $header => $content_array) {
            $content_count = count($content_array) + 1;
            if ($row_count < $content_count) {
                $row_count = $content_count;
            }
        }

        $new_list = [];
        for ($count = 1; $count < $row_count; $count++) {
            $new_list['#'][] = '[' . $count . ']';
        }

        foreach ($raw_list as $header => $content_array) {
            foreach ($content_array as $key => $content) {
                $new_list[$header][$key] = $content;
            }
        }
        return $new_list;
    }

    /**
     * This function unsets any additional columns that exceed the MAX_COLUMNS constant
     * 
     * @param array $array - $this->options_list aka the list of options statically set by whomever uses this class
     * @return array $array - The same passed list, but with columns pruned that exceed the MAX_COLUMNS constant
     */
    private function enforceColumnLimit($array)
    {
        $count = 1;
        foreach ($array as $header => $data) {
            if ($count > SELF::MAX_COLUMNS) {
                unset($array[$header]);
            }
            $count++;
        }
        return $array;
    }

    /**
     * This function takes the raw list of options and returns rows suitable for
     * drawing a Symfony table. Care is taken to ensure that empty values increment
     * the columns so that data is lined up as expected in the table.
     * 
     * @param array $raw_list - A version of $this->options_list after it's been partially processed by $this->prepTableData()
     * @return array $rows - A new array generated for use with the Symfony table's class
     */
    private function generateTableRows($raw_list)
    {
        $rows = [];
        foreach ($raw_list as $header => $row_array) {
            $column_length = count($row_array);
            //Add placeholders for the columns without data so the table lines up correctly
            for ($count = 0; $count < count($raw_list['#']); $count++) {
                if(!isset($row_array[$count])){
                    $row_array[$count] = '';
                }
            }
            foreach ($row_array as $key => $content) {
                if (isset($rows[$key])) {
                    $rows[$key] = array_merge($rows[$key], [$content]);
                } else {
                    $rows[$key] = [$content];
                }
            }
        }
        return $rows;
    }
}